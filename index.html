<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Towards Scala with Finagle at ING Bank</title>

  <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
  <meta name="author" content="Hakim El Hattab">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/ing.css">


  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
  var link = document.createElement( 'link' );
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
  document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>

  <div class="reveal convex center">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

      <section data-markdown>
        ### Towards Scala with Finagle @ ING Bank

      </section>

      <section data-markdown>
        ### Towards ~~Scala~~ *Functional Programming* with Finagle @ ING Bank
        Note:
        * Many talks are on how to get Scala at enterprise, I believe it should be about FP not just Scala
        * I'm going to illustrate this through sharing how adopting Finagle has accelarated the acceptance
        of FP at ING Bank and that the FP aspects of Finagle helped a lot.
      </section>

      <section data-markdown>
        ### Who am I
        * 8 years Committed Functional Programmer
        * FP evangelist at ING Bank
        * Trainer
        * Gets excited by opportunities to remove redundant code through abstraction.
        * Volleyball enthousiast, and referee
        * https://github.com/spockz

        Note:
        * Maintainer of core libraries and frameworks
        * Trainer in functional and reactive programming with Scala and Akka
      </section>

      <section data-markdown>
        ### Today
        * ING Bank & Scala
        * 'Breakthrough'
        * Our task
        * Finagle
        * Future
        * Conclusion
      </section>

      <section>
        <section data-markdown>
          ### Scala @ ING Bank
          - 3 years in the making
          - Small, sound, projects w/o follup

          Note:
          - Somehow the successful projects didn't get followed up by other succesful Scala projects
          - perhaps because of not enough developers and unfamiliarity with the code
        </section>

        <section data-markdown>
          ### The 'breakthrough'
          * Exposure, promotion
          * "Java vs Scala" -> "Functional Programming"
          * Fact-based proof through PoC

          Note:
          - 2+ years of advertisement
          - We will describe one of the latest PoC shortly
          - Personal credits/respect after rebuilding an application to save christmas
          - Credits to Scala/Akka/FP because
          - using them was the only way we could’ve rebuild it so quickly and successfully
          - of the quality of Finagle as discovered with the PoC
          - Raising the discussion from “Java vs Scala” to “we should use FP, which, btw, is easiest to do on existing infrastructure by using Scala”.
          - Benefits for FP:
          - Less state => easier to debug
          - Immutability => easier to reason about applications
          -  also easier to do parallelism
          - Organising / Co-hosting Scaladays 2015 Amsterdam
        </section>
      </section>

      <section>
        <section data-markdown>
          ## Our Task

          Note:
          This is what gave us the 'permission' to keep doing scala
        </section>

        <section data-markdown>
          ### Background

          * From SOAP/XML / JMS
          * To REST API, microservices

          Note:
          - Current ING Landscape
          - Many SOAP/JMS services exposed through multiple busses, almost every feature/page corresponds to a SOAP Service/Action
          - Drawbacks:
          - Busses become SPOFs, and they have been somewhat unstable/overloaded, only so many connections possible per server.
          - Lots of overhead due to SOAP/XML
          - Hard to maintain by owners
          - Hard to discover and consume by users
          - The usual reasons for moving to REST APIs and micro-services apply
          - Smaller units: easier to maintain, use, and run (scale efficiently)
          - Tradeoff: complexity in application traded for increase in communications / network complexity
          - The change:
          - Moving to “outside-in” designed APIs, apis that focus on bundling data and functionality/experiences together based upon usage
          - Removing the EMS
          - Load balancing over dynamically discovered services
          - Resiliency trumps performance
          - We cannot use BackPressure because we have to work with legacy systems and 3rd party systems. BackPressure only works properly when used from the ground up
        </section>

        <section data-markdown>
          ### Our Mission
          > Create a “Resilient HTTP Client” to connect with and between APIS, which integrates / interfaces with existing ING Bank infrastructure
          Note:
          * One of the tasks of the API Platform
        </section>
        <section data-markdown>
          #### Requirements
          - Performance logging
          - Health logging
          - Security / Authentication
          - Service Discovery (zookeeper)
          - Uniform Configuration
        </section>
        <section data-markdown>
          #### Requirements - continued
          - ‘easy’ to use
          - JVM 6+,
          - J2EE Independent
          - Requirement from the team
            > We want to use our time efficiently and spent most of our time implementing ING Bank specific features.
        </section>

        <section data-markdown>
          ### Research
          Existing Libraries and Clients
          - (Rx)Netty
          - Apache HTTP
          - Jersey Client
          - Ribbon / Spring Cloud
          - *Finagle*

          Note:
          - Choose to PoC between Ribbon and Finagle even though it was
          “suggested” to just use Ribbon as it would be familiar to
          developers because it uses RxJava and, moreover, because Hystrix
          was proven to work by and within our home-brew API Framework.
        </section>
      </section>


      <section>
        <section data-markdown>
          ## Finagle
        </section>

        <section data-markdown>
          ### Intro
          * Based on [Your Service as a Function](http://monkey.org/~marius/funsrv.pdf) by [Marius Eriksen](http://monkey.org/~marius/)
          * Originated at Twitter and now used by a lot of companies (Foursquare, ING Bank, Pinterest, SoundCloud, Tumblr, Twitter)
          * Generic RPC Framework
          * Originally in FP style Java,
          * Now in Scala
        </section>

        <section data-markdown>
          ### Main Components
        </section>

        <section data-markdown>
          For asynchronous execution:
          ```scala
          class Future[+A]
          ```
        </section>

        <section data-markdown>
          ```scala
          class Service[-In, +Out] extends (Req) ⇒ Future[Rep]
          ```
          ![stacks](images/service.png)
        </section>

        <section data-markdown>
          ```scala
          class Filter[-ReqIn, +RepOut, +ReqOut, -RepIn]
            extends (ReqIn, Service[ReqOut, RepIn]) ⇒ Future[RepOut]
          ```
          ![stacks](images/filter.png)

          Note:
          - Future - Provides asynchronous execution
          - Service - Abstraction of services, function that takes input and generates a future output
          - Filter - components that are meant to be stacked on top of other Services and Filters
        </section>



        <section data-markdown>
          ### `Stack`
          Uninstantied stack of filter to be, service factories, together with their configurations.
          ![stacks](images/clientstack.svg)
          Note:
          * Default stack for clients
        </section>

        <section data-markdown>
          ### Example: HTTP Call
          ```scala
          val connection = Http.client.newService("www.twitter.com:80")
          val request    = RequestBuilder().url("www.twitter.com/").buildGet()
          val futureRep  = connection(request)
          // Blocking
          println Await.result(futureRep)
          // Nonblocking
          futureRep onSuccess println
          Await.ready(futureRep)
          ```
        </section>

        <section data-markdown>
          ### Example: Adding Time-out
          ```scala
          implicit val timer = DefaultTimer.twitter
          connection(request).within(Duration.fromMilliseconds(30))
          ```
          ```scala
          val timeoutFilter =
          new TimeoutFilter[Request, Response](Duration.fromMilliseconds(30),
          DefaultTimer.twitter)
          val timedConnection = timeoutFilter.andThen(connection)
          timedConnection(request)//.within(Duration.fromMilliseconds(10))
          ```
        </section>

        <section data-markdown>
          ## Implementing our requirements
        </section>

        <section data-markdown>
          <script type="text/template">
            ### Performance logging
            ```xml
            <dependency>
              <groupId>com.github.rlazoti</groupId>
              <artifactId>finagle-metrics_${scala.compat.version}</artifactId>
            </dependency
            ```
          </script>
        </section>

        <section data-markdown>
          ### Health logging
          * Add an Observer to the Observer filter, or
          * Add a Filter
        </section>

        <section data-markdown>
          ### Integrating Health Logging
          ```scala
          class HealthFilter[Req, Rep](component: Component, health: Health)
          extends SimpleFilter[Req, Rep] {

            def apply(request: Req, underlying: Service[Req, Rep]) : Future[Rep] = {
              underlying(request) onSuccess { _ =>
                health.healthy(component)
              } onFailure {
                case _: FailedFastException => health.broken(component)
                case _ =>
              }
            }
          }
          ```
          ```scala
          val connection: Service[Request, Response] = Http.newService()
          val monitoredConnection =
          new HealthFilter(Component("api-x"), Health) andThen connection
          ```
        </section>


        <section data-markdown>
          ### Security / Authentication
          * Additional filter and datatype wrapping the auth context and the http request.
        </section>

        <section data-markdown>
          ### Integrating Authentication
          ```scala
          case class RequestWithAuth(request: Request, auth: AuthContext)
          ```
          ```scala
          class AuthFilter[Rep] extends SimpleFilter[RequestWithAuth, Rep] {

            def apply(req: RequestWithAuth, underlying: Service[Request, Rep]) : Future[Rep] = {
              val request = req.request
              val authHeaders = req.auth.getHeaders
              val builder =
                RequestBuilder()
                  .url(s"http://${request.host.getOrElse("svc")}${request.uri}")
                  .addHeaders(request.headerMap.toMap)
                  .addHeaders(authHeaders)

              val authRequest =
                builder.build(request.method, Some(request.content))

              underlying(authRequest)
            }
          }
          ```
        </section>


        <section data-markdown>
          ### Service-discovery
          ![stacks](images/service-discovery.png)
        </section>
        <!-- <section data-markdown>
          ### `Var`
          ```scala
          trait Var[+T]
          ```

          Embodiment of something that can change, with a `map`, `flatMap`,
          and a `join` function. The essence here is that each reference to a
          `Var` itself is stable but its contents can change.

          ```scala
          > val myVar = new ReadWriteVar(4)
          myVar: ReadWriteVar[Int] = Var(4)@241932831
          > val dependentVar = myVar map (_ * 2)
          dependentVar: Var[Int] = com.twitter.util.Var$$anon$2@61845402
          > dependentVar.sample
          res9: Int = 8
          > myVar.update(21)

          > dependentVar.sample
          res11: Int = 42
          ```
          Note:
          * `Var` resembles `Observable` from RxJava somewhat but isn't meant to
          be a collection. Therefore it has no `filter` methods
        </section>

        <section data-markdown>
          ### `Name`
          Representing a service lookup, a `Name` is either `Bound` or a `Path`.
          * `Bound` consists of a `Var` of `Addr`
          * `Path` alias for a different path, changing the lookup
          * `Addr`
            * `Bound` - Concrete addresses,
            * `Failed` - Something went wrong,
            * `Neg` - Name could not be found,
            * `Pending` - Pending lookup,
        </section>

        <section data-markdown>
          ```scala
          val boundAddr: Var[Addr] = new ReadWriteVar(Addr.Pending)
          val boundName = Name.Bound(boundAddr)
          boundAddr.update(Addr.Bound(new InetSocketAddress("google.com", 80)))
          ```

        </section> -->

        <section data-markdown>
          ### Integrating Service-Discovery
          ```scala
          case class Instance(address: SocketAddress)

          trait ServiceDiscovery {
            def discover(name: String) : rx.Observable[j.u.Collection[Instance]]
          }
          ```
        </section>

        <section data-markdown>
          ```scala
          class OurResolver(discovery: ServiceDiscovery) {
            def eval(service : String) : Name = {
            val discoveredServices : Observable[util.Collection[Service]] =
              serviceDiscovery.findServicesAsObservable(service)

            val discoveredServicesVar : Var[util.Collection[Service]] =
              observableToVar(Collections.emptyList[Service])(discoveredServices)

            val addresses = discoveredServicesVar map { services =>
              servicesToAddr(services.asScala.toList)
            }

            Name.Bound(addresses, id = service)
           }
          }
          Note:
          Left out the types of some methods
          ```
        </section>

        <section data-markdown>
          ```scala
          def observableToVar[T](initial : T)(observable : Observable[T]) : Var[T] = {
            val scalaObservable = JavaConversions.toScalaObservable(observable)
            Var.async(initial) { (updatable : Updatable[T]) =>
              val subscription = scalaObservable.subscribe(updatable.update _)
              Closable.make(_ => Future(subscription.unsubscribe()))
            }
          }
          ```
        </section>

        <section data-markdown>
          ### Together
        </section>

        <section data-markdown>
          ## Performance and Reliability
        </section>
        <section data-markdown>
          ### Setup
          - 1 machine running Gatling talking to
          - 1 machine running production like setup (Tomcat 7 + Jersey + BIO adapter) talking to
          - 2-8 Spray instances running on one machine echoing the request and checking for auth. headers
        </section>
        <section data-markdown>
          ### Performance metrics
          - 5500 RPS
          - Finagle showed a smooth profile

          Note:
          - Both use Netty in the end… so why the difference?
          - We didn't test all different sizes, especially only the smaller
          messages < 8kb
        </section>

        <section data-markdown>
          #### Reliability
          * Failure detected as specified
          * Changes in instances are picked up instantly
        </section>

        <section data-markdown>
          ### Maintainability
          * Helpful community ([mailing list](https://groups.google.com/forum/#!forum/finaglers), [gitter](https://gitter.im/twitter/finagle))
          * *Finagle* is a RPC framework
          * *Finagle* is composable, *Ribbon* is more static
          * *Finagle* different modules are in the same style

          Note:
          - Finagle’s community was and is very helpful on the mailing list and Gitter
          - Finagle is a generic RPC framework so, in contrast to Ribbon, it is re-usable for more than only the HTTP Client. This also makes it easy to re-use the integration with ING Bank infrastructure: our filters and SD integration.
          - There are several projects to integrate finagle with other things: Zookeeper, Redis, PostgreSQL, http, thrift, ..
          - Finagle’s code appears to me more mature, or at least more consistent
        </section>

        <section data-markdown>
          ### Usability / User friendliness
          * Finagle's `Future` is new for most Java devs
          * `map`/`flatMap` are hard to use from pre Java 8


          Note:
          - - *Finagle* comes with its own `Future` type which is slightly different from the Scala version which isn’t bad per se. However, map/flatmap are hard to use from Java < 8
          - + *Ribbon* has nice ORM for mapping to services (https://github.com/Netflix/ribbon/blob/master/ribbon-examples/src/main/java/com/netflix/ribbon/examples/rx/proxy/RxMovieProxyExample.java)
          - + *Finagle* is very composable with Filters and Stacks (more on that later)
        </section>

        <section data-markdown>
          ### Outcome
          * We stuck with *Finagle*
          * It has shown good performance and reliability, it proved
          easy to maintain and extend by our team.
          * Pre Java 8 issues are mitigated by providing additional libraries.


          Note:
          - the reliability and performance. In the end several applications run virtualised on the same hardware so better resource utilisation is appreciated.
          - the maintainability
          - The drawbacks are mitigated by providing additional Java 7 interfaces and by making sure we can use Java 8+ in production in parallel
        </section>
      </section>






        <section data-markdown>
          ### Future
          - We will look into giving Finagle training in addition to the Scala and Akka training already in place.
          - The API Platform team is looking into giving back to the community by open sourcing some of our tools and by giving back more to the Finagle project.
        </section>

        <section data-markdown>
          ## Conclusion
          1. Introducing new paradigms in large organisation takes a lot of time and good timing
          2. The discussion shouldn’t be Java vs Scala but on whether to move to the FP paradigm and the many benefits
          3. Use fact-based evidence to support your decisions
          4. Support from high(er)-management helps a lot
          * Creates room to do the first three points
          * Makes  other people more receptive to your story, sadly enough even with developers who should know better
        </section>


  </div>


  <div class="footer-container">
    <div class="footer reveal">
      <span>Towards Functional Programming with Finagle </span>
      
    </div>
  </div>
</div>


<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: false,
  progress: true,
  history: true,
  center: true,


  transition: 'slide', // none/fade/slide/convex/concave/zoom

  // Optional reveal.js plugins
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true },
    { src: 'plugin/notes/notes.js', async: true }
  ]
});

</script>

</body>
</html>
