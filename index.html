<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Towards Scala with Finagle at ING Bank</title>

  <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
  <meta name="author" content="Hakim El Hattab">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/ing.css">


  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <style type="text/css">
    #finagle {
      padding:0;
      margin: 0;
    }
    .reveal img {
      box-shadow: none;
    }
    #intro img {
      width: 18%;
      box-shadow: none;
    }

    blockquote p:before {
      content: "\201C";
    }

    blockquote p:after {
      content: "\201D";
    }

    section.ul-left ul {
      float:left;
    }
    section.image-right img {
      float:right;
    }
  </style>

  <!-- Printing and PDF exports -->
  <script>
  var link = document.createElement( 'link' );
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
  document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>

  <div class="reveal convex center">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

      <section data-markdown>
        ### Towards Scala with Finagle @ ING Bank
      </section>

      <section data-markdown>
        ### Towards ~~Scala~~ *Functional Programming*
        #### Finagle as an prime FP example
        Note:
        * Many talks are on how to get Scala at enterprise, I believe it should be about FP not just Scala
        * I'm going to illustrate this through sharing how adopting Finagle has accelarated the acceptance
        of FP at ING Bank and that the FP aspects of Finagle helped a lot.
      </section>

      <section data-markdown>
        ### Who am I
        * 8 years Committed Functional Programmer
        * FP evangelist @ ING Bank
        * Trainer
        * Excited by abstracting redundant code
        * Volleyball enthousiast, and referee
        * https://github.com/spockz
      </section>

      <section data-markdown>
        ### Today
        * ING Bank & Scala (FP) 'Breakthrough'
        * Our task
        * Finagle
        * Future
        * Conclusion
      </section>

      <section>
        <section data-markdown>
          ![European map](images/europe.png)
          Note:
          * 3000+ developers, always room for one more brilliant mind
          * Always looking to make things simpler: architecture and code/-reuse
          * Maintainer of core libraries and frameworks as part of API Platform team
          * Trainer in functional and reactive programming with Scala and Akka
        </section>
        <section data-markdown>
          ![Netherlands map](images/netherlands.png)
          Note:
          * Maintainer of core libraries and frameworks as part of API Platform team
          * Trainer in functional and reactive programming with Scala and Akka
        </section>
        <section data-markdown>
          ### Scala @ ING Bank
          - 3 years in the making
          - Small, sound, projects w/o followup

          Note:
          - Somehow the successful projects didn't get followed up by other succesful Scala projects
          - perhaps because of a lack of scala developers and unfamiliarity with FP/Scala
        </section>

        <section data-markdown>
          ### The 'breakthrough'
          1. Exposure, promotion
          2. "Java vs Scala" → "Functional Programming"
          3. Fact-based proof through PoC

          Note:
          - 2+ years of advertisement
          - We will describe one of the latest PoC shortly
          - Personal credits/respect after rebuilding an application to save christmas
          - Credits to Scala/Akka/FP because
          - using them was the only way we could’ve rebuild it so quickly and successfully
          - of the quality of Finagle as discovered with the PoC
          - Raising the discussion from “Java vs Scala” to “we should use FP, which, btw, is easiest to do on existing infrastructure by using Scala”.
          - Benefits for FP:
          - Less state => easier to debug
          - Immutability => easier to reason about applications
          -  also easier to do parallelism
          - Organising / Co-hosting Scaladays 2015 Amsterdam
        </section>

        <section data-markdown>
          ### FP Benefits
          * Better maintainability

          Note:
          * Maintainability includes both adding and fixing of features
          * easier to test because of lang features that makes it easier to create
            small chunks that therefore are easier to test.
        </section>
      </section>

      <section>
        <section data-markdown>
          ### Our Task

          Note:
          This is what gave us the 'permission' to keep doing scala
        </section>

        <section data-markdown>
          ### Background

          To: REST APIs, microservices

          Note:
          - Current ING Landscape
          - Many SOAP/JMS services exposed through multiple buses, almost every feature/page corresponds to a SOAP Service/Action
          - Drawbacks:
          - Busses become SPOFs, and they have been somewhat unstable/overloaded, only so many connections possible per server.
          - Lots of overhead due to SOAP/XML
          - Hard to maintain by owners
          - Hard to discover and consume by users
          - The usual reasons for moving to REST APIs and micro-services apply
          - Smaller units: easier to maintain, use, and run (scale efficiently)
          - Tradeoff: complexity in application traded for increase in communications / network complexity
          - The change:
          - Moving to “outside-in” designed APIs, apis that focus on bundling data and functionality/experiences together based upon usage
          - Removing the EMS
          - Load balancing over dynamically discovered services
          - Resiliency trumps performance
          - We cannot use BackPressure because we have to work with legacy systems and 3rd party systems. BackPressure only works properly when used from the ground up
        </section>

        <section data-markdown>
          ### Our Mission
          > Create a “Resilient HTTP Client” to connect with and between APIS, which integrates with existing ING Bank infrastructure
          Note:
          * One of the tasks of the API Platform
        </section>
        <section data-markdown>
          ### Requirements
          ![Landscape](images/landscape.png)
          Note:
          - Performance logging
          - Health logging
          - Security / Authentication
          - Service Discovery (zookeeper)
          - Uniform Configuration
        </section>
        <section data-markdown>
          ### Requirements - continued
          - ‘easy’ to use
          - ‘easy’ to extend
          - Spring Independent
          - JVM 6+,
          Note:
          * We could be modern with this code, so 6+, but we had to 7+ anyway.
        </section>
        <section data-markdown>
          > We want to use our time efficiently and spent most of our time implementing ING Bank specific features.
        </section>

        <section data-markdown>
          ### Research
          Existing Libraries and Clients
          - (Rx)Netty
          - Apache HTTP
          - Jersey Client
          - Ribbon / Spring Cloud
          - *Finagle*

          Note:
          - Several existing tools, the first three are low-level clients, which do not offer the
        </section>
      </section>


      <section>
        <section data-markdown>
          <script type="text/template">
            <!-- .slide: id="finagle" -->
            ![Finagle](images/finagle.png)
          </script>
        </section>

        <section data-markdown>
          <script type="text/template">
            <!-- .slide: id="intro" -->
            ### Intro
            * [Your Service as a Function](http://monkey.org/~marius/funsrv.pdf) by [Marius Eriksen](http://monkey.org/~marius/)
            * ![Twitter](images/twitter.png)
            * ![FourSquare](images/foursquare-wordmark.png) ![ING Bank](images/logo.hd.png) ![PInterest](images/pinterest.png) ![SoundCloud]](images/soundcloud.png) ![Tumblr](images/tumblr.png)
            * Originally in Java
            Note:
            * Generic RPC Framework
            * Now in Scala
          </script>
        </section>

        <section data-markdown>
          ### Main Components
        </section>

        <section data-markdown>
          ### Asynchronous execution
          ```scala
          class Future[+A]
          ```
        </section>

        <section data-markdown>
          ### Service as a Function
          ![stacks](images/service.png)
        </section>

        <section data-markdown>
          ```scala
          class Filter[-ReqIn, +RepOut, +ReqOut, -RepIn]
            extends (ReqIn, Service[ReqOut, RepIn]) ⇒ Future[RepOut]
          ```
          ![stacks](images/filter.png)

          Note:
          - Future - Provides asynchronous execution
          - Service - Abstraction of services, function that takes input and generates a future output
          - Filter - components that are meant to be stacked on top of other Services and Filters
        </section>
        <section data-markdown>
          ![stacks](images/f-c.png)
          Note:
          Function composition
        </section>



        <section data-markdown>
          ### Stacks
          ![A Stack](images/stack.png)
          Note:
          * Filter factories + configuration
        </section>

        <section data-markdown>
          ### Default Client Stack
          ![stacks](images/clientstack.svg)
          Note:
          * There are three levels of abstraction: service, instance, and connection level, each with own stack.
          * By inserting a TimeOutFilter in a different stack we get different behaviour, timeout on a whole, on an instance or on a connection.
          * Default stack for clients adding a filter on a different spot means
            different behaviour with the same code. Trading complexitity in code
            for complexity in configuration. Analagous to tradeoff when moving
            from monolithic to microservices.
        </section>

        <section data-markdown>
          ### Example: HTTP Call
          ```scala
          val connection = Http.client.newService("api.ing.nl:80")
          val request    = RequestBuilder().url("api.ing.nl/").buildGet()
          val futureRep  = connection(request)
          // Blocking
          println Await.result(futureRep)
          // Nonblocking
          futureRep onSuccess println
          Await.ready(futureRep)
          ```
        </section>

        <section data-markdown>
          ### Example: Adding Time-out
          ```scala
          implicit val timer = DefaultTimer.twitter
          connection(request).within(Duration.fromMilliseconds(30))
          ```
        </section>
        <section data-markdown>
```scala
val timeoutFilter =
  new TimeoutFilter[Request, Response](30 milliseconds,
                                       DefaultTimer.twitter)
val timedConnection = timeoutFilter.andThen(connection)
timedConnection(request)//.within(30 milliseconds)
```
        </section>

        <section data-markdown>
          ## Implementing our requirements
        </section>

        <section data-markdown>
          <script type="text/template">
            ### Performance logging
            ```xml
            <dependency>
              <groupId>com.github.rlazoti</groupId>
              <artifactId>finagle-metrics_${scala.compat.version}</artifactId>
            </dependency
            ```
          </script>
        </section>

        <section data-markdown>
          ### Health logging
          * Add an Observer to the Observer filter, or
          * Add a Filter
        </section>

        <section data-markdown>
          <script type="text/template">
### Integrating Health Logging
```scala
class HealthFilter[Req, Rep](component: Component,
                             health: Health)
  extends SimpleFilter[Req, Rep] {

  def apply(request: Req,
            underlying: Service[Req, Rep]) : Future[Rep] = {
    underlying(request) onSuccess { _ =>
      health.healthy(component)
    } onFailure {
      case _: FailedFastException => health.broken(component)
      case _                      =>
    }
  }
}
```
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
```scala
val connection: Service[Request, Response]
val monitoredConnection =
  new HealthFilter(Component("api-x"), Health) andThen connection
```
          </script>
        </section>


        <section data-markdown>
          ### Security / Authentication
          * Additional filter and datatype wrapping the auth context and the http request.
        </section>

        <section data-markdown>
          <script type="text/template">
### Integrating Authentication
```scala
case class RequestWithAuth(request: Request, auth: AuthContext)
```
```scala
class AuthFilter[Rep]
  extends Filter[RequestWithAuth, Rep, Request, Rep] {

  def apply(req: RequestWithAuth,
            underlying: Service[Request, Rep]) : Future[Rep] = {
    val request = req.request
    val authHeaders = req.auth.getHeaders
    val builder =
      toBuilder(request)
        .addHeaders(authHeaders)

    val authRequest =
      builder.build(request.method, Some(request.content))

    underlying(authRequest)
  }
}
```
          </script>
        </section>


        <section data-markdown>
          ### Service Discovery
          ![stacks](images/service-discovery2.png)

          Note:
          * This abstraction of describing instances (including `Var`) makes it easy to integrate any SD impl with Finagle.
        </section>

        <!-- <section data-markdown>
          ### Integrating Service-Discovery
          ```scala
          case class Instance(address: SocketAddress)

          trait ServiceDiscovery {
            def discover(name: String) : rx.Observable[j.u.Collection[Instance]]
          }
          ```
        </section>

        <section data-markdown>
          ```scala
          class OurResolver(discovery: ServiceDiscovery) {
            def eval(service : String) : Name = {
            val discoveredServices : Observable[util.Collection[Service]] =
              serviceDiscovery.findServicesAsObservable(service)

            val discoveredServicesVar : Var[util.Collection[Service]] =
              observableToVar(Collections.emptyList[Service])(discoveredServices)

            val addresses = discoveredServicesVar map { services =>
              servicesToAddr(services.asScala.toList)
            }

            Name.Bound(addresses, id = service)
           }
          }
          ```
          Note:
          Left out the types of some methods
        </section> -->

        <section data-markdown>
          ### Together
          ```scala
          val resolvedService : Name = new OurResolver(…).eval("api-x")

          val ingFilters    =
            new HealthFilter(Component("api-x"), Health)
              .andThen(new AuthFilter())

          val ingConnection : Service[RequestWithAuth, Response] =
            ingFilters
              .andThen(Httpx.client.newService(resolvedService, "api-x"))
          ```
        </section>

        <section data-markdown>
          ## Performance and Reliability
          Note:
          * Not just form over function!
        </section>
        <section data-markdown>
          ### Setup
          ![Benchmark Setup](images/setup.png)

          Note:
          - 1 machine running Gatling talking to
          - 1 machine running production like setup talking to
          - 0-8 Spray instances running on one machine echoing the request and checking for auth. headers
          todo Image
        </section>
        <section data-markdown>
          ### Performance metrics
          - 5500 RPS
          - Finagle showed a smooth profile

          Note:
          - Both use Netty in the end… so why the difference?
          - We didn't test all different sizes, especially only the smaller
          messages < 8kb
        </section>

        <section data-markdown>
          ### Reliability
          * Failure detected as specified
          * Near-Instant updates
          Note:
          * Changes in instances were picked up instantly
        </section>

        <section data-markdown>
          ### Maintainability
          * Helpful community ([mailing list](https://groups.google.com/forum/#!forum/finaglers), [gitter](https://gitter.im/twitter/finagle))
          * Generic RPC framework
          * Composable
          * *Finagle*'s different modules are in the same style

          Note:
          - Finagle’s community was and is very helpful on the mailing list and Gitter
          - Finagle is a generic RPC framework so, it is re-usable for more than only the HTTP Client. This also makes it easy to re-use the integration with ING Bank infrastructure: our filters and SD integration.
          - There are several projects to integrate finagle with other things: Zookeeper, Redis, PostgreSQL, http, thrift, ..
          - Finagle’s code appears to be mature, or at least consistent
        </section>

        <section data-markdown>
          ### Usability / User friendliness
          * Unfamiliarity with Finagle's `Future`
          * `map`/`flatMap` are hard to use from pre Java 8


          Note:
          * Finagle's Future w/ map/flatMap is new for most of our Java devs
          * *Finagle* comes with its own `Future` type which is slightly different from the Scala version which isn’t bad per se. However, map/flatmap are hard to use from Java < 8
        </section>

        <section data-markdown>
          ### Short recap

          * good performance and reliability
          * easy to maintain and extend
        </section>

        <section data-markdown>
          ### A sober note

          * Default config good 80% of cases
          * Configuration is static
          * [RPC Redux talk](http://monkey.org/~marius/redux.html)

          Note:
          * Special cases require intimate knowledge of both Finagle and infrastructure
          * Configuration is static so adapting to changes in the environment is hard.
          * For more, see the [RPC Redux talk](http://monkey.org/~marius/redux.html)
          * FP, We had to build our own Java 7 interfaces, such as a HTTP Request Builder with support for JSON and such, but also because of the Scala type evidence didn’t really play nice with the Java compiler.
        </section>

        <section data-markdown>
          ### FP Architecture ≠ guaranteed success
          * Mixed adoption of filters
          * Modularisation is hard to teach

          Note:
          * Getting out of the comfort zone is hard, especially without training
          * Mixed - E.g. Some immediately grasp the possibilities, such as
          modularity and ease of testing, of Filter others just don’t. We
          haven’t found a way to explain Filters to them yet that sticks.
        </section>

        <section data-markdown id="end-of-day">
          ### At the end of the day
          * Teams exposed to FP / Scala and are getting enthusiastic
          * Nice, integrated, HTTP client
          * We will stick with *Finagle*

          Note:
          - the reliability and performance. In the end several applications run virtualised on the same hardware so better resource utilisation is appreciated.
          - the maintainability
          - The drawbacks are mitigated by providing additional Java 7 interfaces and by making sure we can use Java 8+ in production in parallel
        </section>

        <section data-markdown>
          ### Future Work
          - More training,
          - Open Sourcing,
          - HOCON for Finagle

          Note:
          * The API Platform team is looking into giving back to the community by open sourcing some of our tools and by giving back more to the Finagle project.
          * Use all cool new Finagle features
        </section>
      </section>





      <section>
        <section data-markdown>
          ### Conclusion
        </section>


        <section data-markdown>
          ### Conclusion
          1. Introducing new paradigms in large organisation takes a lot of time and good timing
          2. "Java vs Scala" → "Functional Programming"
          3. Use fact-based evidence to support your decisions
          4. Support from high(er)-management helps a lot
            * Creates room to do the first three points
            * Makes  other people more receptive to your story, sadly enough even with developers who should know better
        </section>


      </section>
  </div>


  <div class="footer-container">
    <div class="footer reveal">
      <span>Towards Functional Programming with Finagle </span>
    </div>
  </div>
</div>


<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
  controls: false,
  progress: true,
  history: true,
  center: true,

  width: 1000,
  height: 700,

  transition: 'slide', // none/fade/slide/convex/concave/zoom

  // Optional reveal.js plugins
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true },
    { src: 'plugin/notes/notes.js', async: true }
  ]
});

</script>

</body>
</html>
